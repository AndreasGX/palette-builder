<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Color Palette Builder</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#7c5cff}
    *{box-sizing:border-box}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; margin:0; background:linear-gradient(180deg,#071029 0%, #071627 100%); color:#e6eef6; padding:28px}
    .container{max-width:980px;margin:0 auto}
    h1{margin:0 0 14px;font-size:20px}
    .card{background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); padding:16px; border-radius:12px}
    .flex{display:flex;gap:12px;align-items:center}
    .inputs{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;margin-top:12px}
    label{font-size:12px;color:var(--muted)}
    input,button,select{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    input::placeholder{color:#6d7b88}
    .preview{width:46px;height:46px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}
    .controls{margin-top:12px;display:flex;gap:10px}
    .btn{cursor:pointer}
    .palette{margin-top:18px}
    .list{margin-top:10px;display:grid;gap:8px}
    .item{display:flex;align-items:center;gap:12px;padding:10px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border:1px solid rgba(255,255,255,0.02)}
    .meta{flex:1;display:flex;flex-direction:column}
    .codes{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;color:#d7e3f5}
    .small{font-size:12px;color:var(--muted)}
    .actions{display:flex;gap:8px}
    .grow{flex:1}
    .divider{height:12px}
    .footer{margin-top:18px;display:flex;justify-content:space-between;align-items:center}
    .hint{font-size:13px;color:var(--muted)}
    @media (max-width:560px){.flex{flex-direction:column;align-items:stretch}}
	.item.drag-over {
  border: 1px dashed var(--accent);
  background: rgba(124, 92, 255, 0.1);
}
  </style>
</head>
<body>
  <div class="container">
    <h1>Color Palette Builder</h1>
    <div class="card">
	<div id="notification" style="
  position:fixed;
  top:16px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(124,92,255,0.85);
  color:white;
  padding:8px 16px;
  border-radius:8px;
  display:none;
  z-index:1000;
  font-size:14px;
"></div>
      <div class="flex">
        <div style="display:flex;gap:12px;align-items:center">
          <div class="preview" id="livePreview" title="Live preview"></div>
        </div>
        <div class="grow">
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
			<div style="min-width:160px">
				<label for="inputMethod">Input Method</label>
				<select id="inputMethod">
  <option value="hex">HEX</option>
  <option value="rgb">RGB</option>
  <option value="hsl">HSL</option>
  <option value="hsv">HSV</option>
  <option value="oklab">OKLab</option>
  <option value="okhsl">OKHSL</option>
<option value="okhsv">OKHSV</option>
</select>
			</div>
			<div style="min-width:200px">
				<label for="colorInput">Color</label>
				<input id="colorInput" placeholder="Enter color" />
			</div>
			</div>
        </div>
      </div>

      <div class="controls">
        <button id="addBtn" class="btn">Add to palette</button>
        <button id="clearInputsBtn" class="btn">Clear inputs</button>
        <div style="flex:1"></div>
        <button id="exportBtn" class="btn">Export .txt (HEX per line)</button>
        <input type="file" id="importFile" accept=".txt" style="display:none" />
        <button id="importBtn" class="btn">Import .txt</button>
        <select id="savedPalettes" style="min-width:160px"></select>
		<button id="newBtn" class="btn">New Palette</button>
		<button id="saveBtn" class="btn">Save Palette</button>
		<button id="loadBtn" class="btn">Load Palette</button>
		<button id="renameBtn" class="btn">Rename Palette</button>
		<button id="deleteBtn" class="btn">Delete Palette</button>
      </div>

      <div class="divider"></div>

      <div class="palette">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">Palette</div>
          <div class="hint">Click a code to copy. Edit or remove entries below.</div>
        </div>
        <div id="list" class="list"></div>
        <div class="footer">
          <div class="small">Total colors: <span id="count">0</span></div>
          <div>
            <button id="clearPalette" class="btn">Clear palette</button>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
const listEl = document.getElementById('list');
const countEl = document.getElementById('count');
const livePreview = document.getElementById('livePreview');
const addBtn = document.getElementById('addBtn');
const clearInputsBtn = document.getElementById('clearInputsBtn');
const exportBtn = document.getElementById('exportBtn');
const clearPaletteBtn = document.getElementById('clearPalette');
const newBtn = document.getElementById('newBtn');
const saveBtn = document.getElementById('saveBtn');
const loadBtn = document.getElementById('loadBtn');
const importBtn = document.getElementById('importBtn');
const importFile = document.getElementById('importFile');

function scale504ToUnit(x) {
    return clamp(x / 504, 0, 1);
}

function scaleUnitTo504(x) {
    return +(clamp(x,0,1) * 504).toFixed(3);
}

function buildColorObject(rgb) {
  const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  return { hex, ...rgb, ...hsl };
}

function addRgbToPalette(rgb) {
  palette.push(buildColorObject(rgb));
  update();
  showNotification('Color added.');
}

function showNotification(msg, duration=1200){
  const notif = document.getElementById('notification');
  notif.innerText = msg;
  notif.style.display = 'block';
  clearTimeout(notif._timeout);
  notif._timeout = setTimeout(() => {
    notif.style.display = 'none';
  }, duration);
}

function srgbToLinear(c) { 
  return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
}

function linearToSrgb(c) { 
  return c <= 0.0031308 ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
}

function oklabToLinearSrgb(L, a, b) {
  const l_ = Math.pow(L + 0.3963377774 * a + 0.2158037573 * b, 3);
  const m_ = Math.pow(L - 0.1055613458 * a - 0.0638541728 * b, 3);
  const s_ = Math.pow(L - 0.0894841775 * a - 1.291485548 * b, 3);

  return {
    r: 4.0767416621 * l_ - 3.3077115913 * m_ + 0.2309699292 * s_,
    g: -1.2684380046 * l_ + 2.6097574011 * m_ - 0.3413193965 * s_,
    b: -0.0041960863 * l_ - 0.7034186147 * m_ + 1.707614701 * s_
  };
}

function linearSrgbToOklab(r, g, b) {
  const l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
  const m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
  const s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

  const l_ = Math.cbrt(l), m_ = Math.cbrt(m), s_ = Math.cbrt(s);

  return {
    L: 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_,
    a: 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_,
    b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_
  };
}

function toe(x) {
  const k1 = 0.206, k2 = 0.03, k3 = (1 + k1) / (1 + k2);
  return 0.5 * (k3 * x - k1 + Math.sqrt((k3 * x - k1) ** 2 + 4 * k2 * k3 * x));
}

function toeInv(x) {
  const k1 = 0.206, k2 = 0.03, k3 = (1 + k1) / (1 + k2);
  return (x * x + k1 * x) / (k3 * (x + k2));
}

function computeMaxSaturation(a, b) {
  let k0, k1, k2, k3, k4;
  if (-1.88170328 * a - 0.80936493 * b > 1) {
    k0 = 1.19086277; k1 = 1.76576728; k2 = 0.59662641; k3 = 0.75515197; k4 = 0.56771245;
  } else if (1.81444104 * a - 1.19445276 * b > 1) {
    k0 = 0.73956515; k1 = -0.45954404; k2 = 0.08285427; k3 = 0.1254107; k4 = 0.14503204;
  } else {
    k0 = 1.35733652; k1 = -0.00915799; k2 = -1.1513021; k3 = -0.50559606; k4 = 0.00692167;
  }
  return k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;
}

function toST(cusp) {
  const Lc = cusp[0];
  const Cc = cusp[1];
  return { S: Cc / Lc, T: Cc / (1 - Lc) };
}

function findCusp(a, b) {
  const S_cusp = computeMaxSaturation(a, b);
  const rgb = oklabToLinearSrgb(1, S_cusp*a, S_cusp*b);
  const L_cusp = Math.cbrt(1/Math.max(rgb.r, rgb.g, rgb.b));
  const C_cusp = L_cusp*S_cusp;
  return [L_cusp, C_cusp];
}

function oklabToSrgb(L, a, b) {
  const lin = oklabToLinearSrgb(L, a, b);
  return {
    r: Math.round(clamp(linearToSrgb(lin.r)) * 255),
    g: Math.round(clamp(linearToSrgb(lin.g)) * 255),
    b: Math.round(clamp(linearToSrgb(lin.b)) * 255)
  };
}

function okhslToSrgb(h, s, l) {
  if (l <= 0) return { r: 0, g: 0, b: 0 };
  if (l >= 1) return { r: 255, g: 255, b: 255 };
  const a_ = Math.cos(2 * Math.PI * h);
  const b_ = Math.sin(2 * Math.PI * h);
  const L = toeInv(l);
  const [L_cusp, C_cusp] = findCusp(a_, b_);
  const C_max = L < L_cusp ? C_cusp * (L / L_cusp) : C_cusp * ((1 - L) / (1 - L_cusp));
  const C = s * C_max;

  const rgbLin = oklabToLinearSrgb(L, C * a_, C * b_);
  return {
    r: Math.round(clamp(linearToSrgb(rgbLin.r)) * 255),
    g: Math.round(clamp(linearToSrgb(rgbLin.g)) * 255),
    b: Math.round(clamp(linearToSrgb(rgbLin.b)) * 255)
  };
}

function okhsvToSrgb(h, s, v) {
  if (v <= 0) return { r: 0, g: 0, b: 0 };
  if (v >= 1 && s === 0) return { r: 255, g: 255, b: 255 };

  const a_ = Math.cos(2 * Math.PI * h);
  const b_ = Math.sin(2 * Math.PI * h);
  const cusp = findCusp(a_, b_);
  const ST = { S: cusp[1] / cusp[0], T: cusp[1] / (1 - cusp[0]) };
  const S_0 = 0.5;
  const k = 1 - S_0 / ST.S;
  const L_v = 1 - (s * S_0) / (S_0 + ST.T - ST.T * k * s);
  const C_v = (s * ST.T * S_0) / (S_0 + ST.T - ST.T * k * s);

  let L = v * L_v;
  let C = v * C_v;

  const L_vt = toeInv(L_v);
  const C_vt = (C_v * L_vt) / L_v;
  const L_new = toeInv(L);
  C *= L_new / L;
  L = L_new;

  const rgbLin = oklabToLinearSrgb(L, C * a_, C * b_);
  return {
    r: Math.round(clamp(linearToSrgb(rgbLin.r)) * 255),
    g: Math.round(clamp(linearToSrgb(rgbLin.g)) * 255),
    b: Math.round(clamp(linearToSrgb(rgbLin.b)) * 255)
  };
}

function srgbToOklab(r, g, b) {
  r = srgbToLinear(r / 255);
  g = srgbToLinear(g / 255);
  b = srgbToLinear(b / 255);
  return linearSrgbToOklab(r, g, b);
}

function srgbToOkhsl(r,g,b){
  r = srgbToLinear(r/255); g = srgbToLinear(g/255); b = srgbToLinear(b/255);
  const lab = linearSrgbToOklab(r,g,b);
  const C = Math.sqrt(lab.a*lab.a + lab.b*lab.b);
  const h = Math.atan2(lab.b, lab.a)/(2*Math.PI);
  const a_ = lab.a/C; 
  const b_ = lab.b/C;
  const s = C/findCusp(a_,b_)[1];
  const l = toe(lab.L);
  return { h, s, l }; // <-- return raw 0-1
}

function srgbToOkhsv(r, g, b) {
  const rl = srgbToLinear(r / 255);
  const gl = srgbToLinear(g / 255);
  const bl = srgbToLinear(b / 255);

  const lab = linearSrgbToOklab(rl, gl, bl); // {L, a, b}
  let C = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
  let a_, b_;
  if (C === 0) {
    a_ = 1;
    b_ = 0;
  } else {
    a_ = lab.a / C;
    b_ = lab.b / C;
  }
  let h = 0.5 + 0.5 * Math.atan2(-lab.b, -lab.a) / Math.PI;
  if (!Number.isFinite(h)) h = 0;
  const cusp = findCusp(a_, b_);
  const ST = toST(cusp);
  const S_max = ST.S;
  const T_max = ST.T;
  const S_0 = 0.5;
  const k = 1 - S_0 / S_max;
  const t = T_max / (C + lab.L * T_max || 1e-9);
  let L_v = t * lab.L;
  let C_v = t * C;
  const L_vt = toeInv(L_v);
  const C_vt = (C_v * L_vt) / (L_v === 0 ? 1e-9 : L_v);
  const rgbScale = oklabToLinearSrgb(L_vt, a_ * C_vt, b_ * C_vt);
  const maxComp = Math.max(rgbScale.r, rgbScale.g, rgbScale.b, 0);
  const scale_L = Math.cbrt(1 / (maxComp === 0 ? 1e-9 : maxComp));
  let L = lab.L / scale_L;
  C = C / scale_L;
  C = C * toe(L) / (L === 0 ? 1e-9 : L);
  L = toe(L);
  const v = L / (L_v === 0 ? 1e-9 : L_v);
  const s = ((S_0 + T_max) * C_v) / ((T_max * S_0) + T_max * k * C_v || 1e-9);

  return { h: (h < 0 ? h + 1 : (h > 1 ? h - 1 : h)), s: clamp(s, 0, 1), v: clamp(v, 0, 1) };
}

function clamp(v, a = 0, b = 1) { return Math.min(b, Math.max(a, v)); }

function hexToRgb(hex){ if(!hex) return null; hex=hex.replace(/[^0-9a-f]/gi,''); if(hex.length===3) hex=hex.split('').map(c=>c+c).join(''); if(hex.length!==6) return null; const n=parseInt(hex,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
function rgbToHex(r,g,b){ r=Math.round(clamp(r,0,255)); g=Math.round(clamp(g,0,255)); b=Math.round(clamp(b,0,255)); return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('').toUpperCase(); }
function rgbToHsl(r,g,b){ r/=255;g/=255;b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2; if(max===min){h=s=0;} else{ const d=max-min; s = l>0.5? d/(2-max-min): d/(max+min); switch(max){case r: h=(g-b)/d + (g<b?6:0); break; case g: h=(b-r)/d + 2; break; case b: h=(r-g)/d + 4; break;} h/=6; } return {h:Math.round(h*360), s:Math.round(s*100), l:Math.round(l*100)} }
function hslToRgb(h,s,l){ h=((h%360)+360)%360; s=clamp(s,0,100)/100; l=clamp(l,0,100)/100; if(s===0){const v=Math.round(l*255); return {r:v,g:v,b:v};} const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q; const hk = h/360; const calc = (t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p + (q - p) * 6 * t; if(t<1/2) return q; if(t<2/3) return p + (q - p) * (2/3 - t) * 6; return p; }
  const r=Math.round(calc(hk+1/3)*255); const g=Math.round(calc(hk)*255); const b=Math.round(calc(hk-1/3)*255); return {r,g,b}; }
function rgbToHsv(r, g, b) {
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  const d = max - min;
  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;

  if (d !== 0) {
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    v: Math.round(v * 100)
  };
}
function hsvToRgb(h, s, v) {
  h = ((h % 360) + 360) % 360;
  s = clamp(s, 0, 100) / 100;
  v = clamp(v, 0, 100) / 100;

  const c = v * s;
  const x = c * (1 - Math.abs((h / 60) % 2 - 1));
  const m = v - c;

  let r1, g1, b1;
  if (h < 60) [r1, g1, b1] = [c, x, 0];
  else if (h < 120) [r1, g1, b1] = [x, c, 0];
  else if (h < 180) [r1, g1, b1] = [0, c, x];
  else if (h < 240) [r1, g1, b1] = [0, x, c];
  else if (h < 300) [r1, g1, b1] = [x, 0, c];
  else [r1, g1, b1] = [c, 0, x];

  return {
    r: Math.round((r1 + m) * 255),
    g: Math.round((g1 + m) * 255),
    b: Math.round((b1 + m) * 255)
  };
}

function parseHexInput(v){ if(!v) return null; const rgb=hexToRgb(v); return rgb; }
function parseRgbInput(v){
  const m = v.match(/\(?\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)?/i);
  if(!m) return null;
  const r = parseInt(m[1], 10);
  const g = parseInt(m[2], 10);
  const b = parseInt(m[3], 10);
  if ([r,g,b].some(isNaN)) return null;
  return {r: clamp(r,0,255), g: clamp(g,0,255), b: clamp(b,0,255)};
}

function parseHslInput(v){
  v = v.replace(/hsl\(|\)/gi,'').trim();
  const m = v.split(/[,\s]+/).map(Number);
  if (m.length !== 3 || m.some(isNaN)) return null;
  const h = scale504ToUnit(m[0]);  // 0–504 → 0–1
  const s = scale504ToUnit(m[1]);
  const l = scale504ToUnit(m[2]);
  return hslToRgb(h*360, s*100, l*100); // internal HSLToRGB expects normal 0–360,0–100%
}


function parseHsvInput(v){
  v = v.replace(/hsv\(|\)/gi,'').trim();
  const m = v.split(/[,\s]+/).map(Number);
  if (m.length !== 3 || m.some(isNaN)) return null;

  const h = scale504ToUnit(m[0]);  // 0–504 → 0–1
  const s = scale504ToUnit(m[1]);
  const val = scale504ToUnit(m[2]);
  return hsvToRgb(h*360, s*100, val*100); // internal HSVToRGB expects normal 0–360,0–100%
}


function parseOklabInput(v) {
  v = v.replace(/oklab\(|\)/gi, '').trim();
  const m = v.match(/(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/);
  if (!m) return null;
  const L = parseFloat(m[1]);
  const a = parseFloat(m[2]);
  const b = parseFloat(m[3]);
  if ([L, a, b].some(isNaN)) return null;
  return oklabToSrgb(L, a, b);
}

function parseOkhslInput(v){
  v = v.replace(/okhsl\(|\)/gi,'').trim();
  const m = v.split(/[,\s]+/).map(Number);
  if (m.length !== 3 || m.some(isNaN)) return null;

  const h = scale504ToUnit(m[0]);  // 0–504 → 0–1
  const s = scale504ToUnit(m[1]);
  const l = scale504ToUnit(m[2]);
  return okhslToSrgb(h, s, l);
}

function parseOkhsvInput(v){
  v = v.replace(/okhsv\(|\)/gi,'').trim();
  const m = v.split(/[,\s]+/).map(Number);
  if (m.length !== 3 || m.some(isNaN)) return null;

  const h = scale504ToUnit(m[0]);  
  const s = scale504ToUnit(m[1]);
  const vv = scale504ToUnit(m[2]);
  return okhsvToSrgb(h, s, vv);
}

const inputMethod = document.getElementById('inputMethod');
const colorInput = document.getElementById('colorInput');

function getRgbFromSingleInput() {
  const method = inputMethod.value;
  let val = colorInput.value.trim();

  val = val.replace(/\s+/g, '');

  if (!val) return null;
  let rgb = null;
  switch(method) {
    case 'hex': rgb = parseHexInput(val); break;
    case 'rgb': rgb = parseRgbInput(val); break;
    case 'hsl': rgb = parseHslInput(val); break;
    case 'hsv': rgb = parseHsvInput(val); break;
	case 'oklab': rgb = parseOklabInput(val); break;
	case 'okhsl': rgb = parseOkhslInput(val); break;
  case 'okhsv': rgb = parseOkhsvInput(val); break;
}
  if(!rgb) console.log('Failed to parse color:', val, 'method:', method);
  return rgb;
}

function updateLivePreview() {
  const rgb = getRgbFromSingleInput();
  livePreview.style.background = rgb ? rgbToHex(rgb.r,rgb.g,rgb.b) : 'linear-gradient(45deg,#2b3441,#0e1620)';
}

colorInput.addEventListener('input', updateLivePreview);
inputMethod.addEventListener('change', updateLivePreview);

function addColorFromSingleInputUnified() {
  const rgb = getRgbFromSingleInput();
  if (rgb) addRgbToPalette(rgb);
}

addBtn.addEventListener('click', addColorFromSingleInputUnified);
colorInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    addColorFromSingleInputUnified();
  }
});

let palette = [];
let currentPaletteName = null;

function renderList() {
  listEl.innerHTML = '';
  palette.forEach((c, idx) => {
    const item = document.createElement('div');
    item.className = 'item';

    const swatch = document.createElement('div');
    swatch.style.width = '46px';
    swatch.style.height = '46px';
    swatch.style.borderRadius = '8px';
    swatch.style.background = c.hex;
    swatch.style.flex = '0 0 46px';
    swatch.style.border = '1px solid rgba(0,0,0,0.25)';
    item.appendChild(swatch);

    const meta = document.createElement('div');
    meta.className = 'meta';

    // Top line: Hex, RGB, OKLab
    const codes = document.createElement('div');
    codes.className = 'codes';
    const oklab = srgbToOklab(c.r, c.g, c.b);
    codes.innerText = `${c.hex}  —  rgb(${c.r}, ${c.g}, ${c.b})  —  OKLab(L=${oklab.L.toFixed(3)}, a=${oklab.a.toFixed(3)}, b=${oklab.b.toFixed(3)})`;
    codes.title = 'Click to copy HEX';
    codes.style.cursor = 'pointer';
    codes.addEventListener('click', () => {
      navigator.clipboard.writeText(c.hex);
      codes.innerText = 'Copied: ' + c.hex;
      setTimeout(() => renderList(), 700);
    });
    meta.appendChild(codes);

    // Bottom line: HSL, HSV, OKHSL, OKHSV
    const small = document.createElement('div');
    small.className = 'small';
    const hsv = rgbToHsv(c.r, c.g, c.b);
    const okhsl = srgbToOkhsl(c.r, c.g, c.b);
    const okhsv = srgbToOkhsv(c.r, c.g, c.b);
    small.innerText =
  `HSL: ${c.h} , ${c.s} , ${c.l} • ` +
  `HSV: ${hsv.h} , ${hsv.s} , ${hsv.v} • ` +
  `OKHSL: ${scaleUnitTo504(okhsl.h)} , ${scaleUnitTo504(okhsl.s)} , ${scaleUnitTo504(okhsl.l)} • ` +
  `OKHSV: ${scaleUnitTo504(okhsv.h)} , ${scaleUnitTo504(okhsv.s)} , ${scaleUnitTo504(okhsv.v)}`;
    meta.appendChild(small);

    item.appendChild(meta);

    const actions = document.createElement('div');
    actions.className = 'actions';
    const editBtn = document.createElement('button');
    editBtn.innerText = 'Edit';
    editBtn.className = 'btn';
    editBtn.addEventListener('click', () => openEditor(idx));
    const delBtn = document.createElement('button');
    delBtn.innerText = 'Remove';
    delBtn.className = 'btn';
    delBtn.addEventListener('click', () => {
      if (!confirm('Remove this color?')) return;
      palette.splice(idx, 1);
      update();
    });
    actions.appendChild(editBtn);
    actions.appendChild(delBtn);
    item.appendChild(actions);

    listEl.appendChild(item);
  });

  countEl.innerText = palette.length;
  enableDragAndDrop();
}

function enableDragAndDrop() {
  const items = listEl.querySelectorAll('.item');
  let dragSrcIndex = null;

  items.forEach((item, index) => {
    item.draggable = true;

item.addEventListener('dragstart', e => {
  dragSrcIndex = index;
  item.style.opacity = '0.4';
  e.dataTransfer.effectAllowed = 'move';

  const ghost = item.cloneNode(true);
  ghost.style.position = 'absolute';
  ghost.style.top = '-9999px';
  ghost.style.left = '-9999px';
  document.body.appendChild(ghost);
  e.dataTransfer.setDragImage(ghost, 25, 25);
  setTimeout(() => document.body.removeChild(ghost), 0);
});

    item.addEventListener('dragend', () => {
      item.style.opacity = '1';
      listEl.querySelectorAll('.item').forEach(i => i.classList.remove('drag-over'));
    });

    item.addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      item.classList.add('drag-over');
    });

    item.addEventListener('dragleave', () => {
      item.classList.remove('drag-over');
    });

    item.addEventListener('drop', e => {
      e.preventDefault();
      item.classList.remove('drag-over');
      if (dragSrcIndex === null || dragSrcIndex === index) return;
      const moved = palette.splice(dragSrcIndex, 1)[0];
      palette.splice(index, 0, moved);
      renderList();
    });
  });
}
function update(){ renderList(); }
function hexFromRgbObj(o){ return rgbToHex(o.r,o.g,o.b); }

clearInputsBtn.addEventListener('click', () => {
  colorInput.value = '';
  updateLivePreview();
});

clearPaletteBtn.addEventListener('click',()=>{
  if(!confirm('Clear entire palette?')) return;
  palette=[];
  update();
});

function openEditor(index) {
  const c = palette[index];
  const newVal = prompt(`Edit color (${inputMethod.value.toUpperCase()}):`, c.hex);
  if (newVal === null) return;

  const rgb = (() => {
    switch (inputMethod.value) {
      case 'hex': return parseHexInput(newVal);
      case 'rgb': return parseRgbInput(newVal);
      case 'hsl': return parseHslInput(newVal);
      case 'hsv': return parseHsvInput(newVal);
	  case 'oklab': return parseOklabInput(newVal);
	  case 'okhsl': return parseOkhslInput(newVal);
	  case 'okhsv': return parseOkhsvInput(newVal);
      default: return null;
    }
  })();

  if (!rgb) {
    showNotification('Invalid color');
    return;
  }

palette[index] = buildColorObject(rgb);
update();
showNotification('Color updated.');
}

exportBtn.addEventListener('click',()=>{
  if(palette.length===0){ showNotification('Palette is empty.'); return; }
  const content = palette.map(c=>c.hex).join('\n');
  const blob = new Blob([content], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download='palette.txt';
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  showNotification('Palette exported.');
});

importBtn.addEventListener('click',()=>{ importFile.click(); });
importFile.addEventListener('change',(e)=>{
  const file = e.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = function(ev){
    const lines = ev.target.result.split(/\r?\n/).map(l=>l.trim()).filter(l=>l);
    let added=0;
    lines.forEach(l=>{ const rgb=parseHexInput(l); if(rgb){ const hex=hexFromRgbObj(rgb); const hsl=rgbToHsl(rgb.r,rgb.g,rgb.b); palette.push({hex:hex,r:rgb.r,g:rgb.g,b:rgb.b,h:hsl.h,s:hsl.s,l:hsl.l}); added++; } });
    update();
    showNotification(`Imported ${added} colors.`);
  };
  reader.readAsText(file);
});

const savedPalettes = document.getElementById('savedPalettes');
const renameBtn = document.getElementById('renameBtn');
const deleteBtn = document.getElementById('deleteBtn');

function getSavedPalettes() {
  return JSON.parse(localStorage.getItem('savedPalettes') || '{}');
}

function savePalettes(data) {
  localStorage.setItem('savedPalettes', JSON.stringify(data));
}

function updateSavedDropdown() {
  const data = getSavedPalettes();
  savedPalettes.innerHTML = '';
  Object.keys(data).forEach(name => {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    savedPalettes.appendChild(opt);
  });
}
updateSavedDropdown();

newBtn.onclick = () => {
  if (palette.length > 0 && !confirm('Start a new palette? Unsaved changes will be lost.')) return;
  palette = [];
  currentPaletteName = null;
  update();
  savedPalettes.value = '';
  showNotification('Started a new palette.');
};

saveBtn.onclick = () => {
  const data = getSavedPalettes();

  if (currentPaletteName && data[currentPaletteName]) {
    data[currentPaletteName] = [...palette];
    savePalettes(data);
    showNotification(`Palette "${currentPaletteName}" updated!`);
    return;
  }

  const name = prompt('Enter a name for this palette:');
  if (!name) return;

  data[name] = palette.map(c => c.hex);
  savePalettes(data);
  updateSavedDropdown();
  savedPalettes.value = name;
  currentPaletteName = name;
  showNotification(`Palette "${name}" saved!`);
};

loadBtn.onclick = () => {
  const name = savedPalettes.value;
  if (!name) return showNotification('Select a palette to load.');
  const data = getSavedPalettes();
  if (data[name]) {
    palette = data[name].map(hex => {
  const rgb = hexToRgb(hex);
  const hsl = rgbToHsl(rgb.r,rgb.g,rgb.b);
  return {hex, ...rgb, ...hsl};
});
    currentPaletteName = name;
    update();
    showNotification(`Palette "${name}" loaded.`);
  } else {
    showNotification('Selected palette not found.');
  }
};

renameBtn.onclick = () => {
  const oldName = savedPalettes.value;
  if (!oldName) return showNotification('Select a palette to rename.');
  const newName = prompt('Enter new name:', oldName);
  if (!newName) return;
  const data = getSavedPalettes();
  if (data[newName]) {
    if (!confirm('A palette with that name exists. Overwrite?')) return;
  }
  data[newName] = data[oldName];
  delete data[oldName];
  savePalettes(data);
  updateSavedDropdown();
  savedPalettes.value = newName;
  showNotification(`Renamed to "${newName}".`);
};

deleteBtn.onclick = () => {
  const name = savedPalettes.value;
  if (!name) return showNotification('Select a palette to delete.');
  if (!confirm(`Delete palette "${name}"?`)) return;
  const data = getSavedPalettes();
  delete data[name];
  savePalettes(data);
  updateSavedDropdown();
  showNotification(`Deleted "${name}".`);
  if (currentPaletteName === name) {
  currentPaletteName = null;
  palette = [];
  update();
}
};

updateLivePreview(); update();
</script>
</body>
</html>